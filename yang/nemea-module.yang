submodule "nemea-module" {
	belongs-to "nemea" { prefix "nemea"; }

	typedef "trap-ifc-type" {
    type "enumeration" {
      enum "TCP" { description "IP/TCP for intermachine connections."; }
			enum "TCP-TLS" { description "Same as TCP but using TLS on top."; }
      enum "UNIXSOCKET" { description "UNIX socket for local connections."; }
      enum "FILE" { description "File interface for loading or saving the data from or to a file."; }
      enum "BLACKHOLE" { description "Output interface dropping everything."; }
    }
    description "Trap interface type.";
  }

  typedef "trap-ifc-dir" {
    type "enumeration" {
      enum "IN" { description "Input interface."; }
      enum "OUT" { description "Output interface."; }
    }
    description "Direction of trap interface.";
  }

	typedef "full-file-path" {
		type "string" { 
			length "1..255";
			pattern "^/"; 
		}
		description "Full UNIX path to file";
	}

	grouping "tls-key-cert-ca-files" {
		leaf "keyfile" {
			type "full-file-path";
			mandatory "true";
			description "Path to private key file in PEM format.";
		}
		leaf "certfile" {
			type "full-file-path";
			mandatory "true";
			description "Path to certificate file in PEM format.";
		}
		leaf "cafile" {
			type "full-file-path";
			mandatory "true";
			description "Path to CA certificate file in PEM format.";
		}
	}

	grouping "tcp-port" {
    leaf "port" {
      type "inet:port-number";
      mandatory "true";
      description "Port number indetifying TCP socket.";
    }
	}

	grouping "tcp-host-and-port" {
    leaf "host" { 
      type "inet:host"; 
      description "Hostname or IP address identifying TCP socket." + 
                  " Host option can be skipped and in that case localhost is used.";
    }
		uses "tcp-port";
	}

	grouping "trap-ifc-max-clients" {
		leaf "max-clients" {
			type "uint16" { range "1..65535"; }
			/* libtrap default 64; */
			description "Maximal number of connected clients (input interfaces).";
		}
	}

	grouping "unix-socket-name" {
		leaf "socket-name" {
			type "string" { length "1..255"; }
			mandatory "true";
			description "Name of UNIX socket to connect to.";
		}
	}

	grouping "trap-ifc-file-name" {
		leaf "name" {
			type "string" { length "1..255"; }
			mandatory "true";
			description "Name of file to be used as interface.";
		}
	}

	grouping "trap-ifc-timeout" {
    leaf "timeout" {
      type "string" { pattern "^(([1-9]+[0-9]*)|WAIT|NO_WAIT|HALF_WAIT)"; }
      /* libtrap default "WAIT"; */
      description "Time in microseconds that an IFC can block waiting for" +
                  " message send/receive. Or one of special values.";
    }
	}

grouping "nemea-module" {
	list "module" {
		key "name";
		leaf "name" {
			type "string" {
			length "1..255";
				pattern "[0-9a-zA-Z _-]+";
			}
			mandatory "true";
			description "Unique name of the module instance.";
		}
	
		leaf "path" {
			type "string" {
				pattern "^/.+";
			}
			mandatory "true";
			description "Full path to where module binary resides.";
		}
	
		list "config" {
			key "name";
			description "Specific configuration of the module";
			leaf "name" {
				type "string" {
					length "1..255";
					pattern "[0-9a-zA-Z _-]+";
				}
				mandatory "true";
			}

      leaf "path" {
        type "string" {
          pattern "^/.+";
        }
        mandatory "true";
        description "Full path to where module binary resides.";
      }
      leaf "enabled" {
        type "boolean";
        mandatory "true";
        description "Specify whether to start the module or not.";
      }
      leaf "max-restarts-per-min" {
        type "uint8";
        default "3";
        description "How many times the module will be automatically restarted (in case it
                     terminated) before setting disabled";
      }
      leaf "last-pid" {
        type "uint32" { range "1..max"; }
        description "In case supervisor was interrupted and shouldn't have stopped the
                     modules, PID of this Nemea module process is stored so that
                     supervisor can reconnect to it once it starts again.";
      }
      leaf "params" {
          type "string";
      }


		} // End list "config"
	} // End list "module"
} // End grouping "nemea-module"

  /* Begin grouping interfaces list */
  grouping "trap-ifcs-list" {


		/* Begin list interface */
  	list "interface" {
  	  key "id";
  	  //key "type direction";
			// TODO!!!!! just temporary because of unirecfilter & merger modules_ll, those can have multiple IN/OUT ifaces
			leaf "id" { type "uint8"; mandatory true; }
  	  leaf "type" {
  	    type "trap-ifc-type";
  	    mandatory "true";
  	    description "Type of libtrap communication interface.";
  	  }
  	  leaf "direction" {
  	    type "trap-ifc-dir";
  	    mandatory "true";
  	    description "Type of libtrap communication interface.";
  	  }

			/* Definitions of IN interface specific parameters as defined by IFC_SPEC of libtrap */
			container "in-params" {
				when "../direction = 'IN'";
				/* IN interface can not specify option HALF_WAIT. Validation for this is bellow. */
				uses "trap-ifc-timeout";
				must "timeout != 'HALF_WAIT'" {
						error-message "IN interface can't use timeout option HALF_WAIT!";
				}
				
				choice "trap-ifc-type-in-params" {
          case "for-tcp" {
						container "tcp-params" {
							uses "tcp-host-and-port";
						}
          }
          case "for-tcp-tls" {
						container "tcp-tls-params" {
							uses "tcp-host-and-port";
							uses "tls-key-cert-ca-files";
						}
          }
          case "for-unix" {
						container "unix-params" { uses "unix-socket-name";	}
          }
          case "for-file" {
						container "file-params" { uses "trap-ifc-file-name"; }
          }
				}
			}

			/* Definitions of OUT interface specific parameters as defined by IFC_SPEC of libtrap */
			/* Begin container out-params */
			container "out-params" {
				when "../direction = 'OUT'";
				uses "trap-ifc-timeout";


	  	  leaf "buffer" {
	  	    type "string" { pattern "^(on|off)"; }
	  	    /* libtrap default "on"; */
	  	    description "Specifies buffering of data and whether to send in" +
											" larger bulks (increases troughput).";
	  	  }
	
	  	  leaf "autoflush" {
	  	    type "string" { pattern "^(off|[1-9][0-9]*)"; }
	  	    /* libtrap default "500000"; */
	  	    description "Normally data are not sent until the buffer is full." +
											" When autoflush is enabled, even non-full buffers" +
											" are sent every X microseconds.";
	  	  }
	
				choice "trap-ifc-type-out-params" {
					case "for-tcp" {
						container "tcp-params" {
							uses "tcp-port";
							uses "trap-ifc-max-clients";
						}
					}
					case "for-tcp-tls" {
						container "tcp-tls-params" {
							uses "tcp-port";
							uses "trap-ifc-max-clients";
							uses "tls-key-cert-ca-files";
						}
					}
					case "for-unix" {
						container "unix-params" {
							uses "unix-socket-name";
							uses "trap-ifc-max-clients";
						}
					}
					case "for-file" {
						container "file-params" {
							uses "trap-ifc-file-name";
							leaf "mode" {
								type "string" { pattern "[aw]"; length 1; }
								default "a";
								description "Defines file access mode, 'a' for append and 'w' for write." +
														" Append mode creates new file with an integer suffix" +
														" e.g. data.trapcap.0 if the former exists.";
							}
							leaf "time" {
								type "uint16" { range "1..65535"; }
								description "If set, interface will split captured data to individual files" +
														" as often, as value of this parameter indicates. Values are in" +
														" minutes and format of created files is 'filename.YYYYmmddHHMM'." +
														" If both 'time' and 'size' options are specified, the data are" +
														" split primarily by time, and only if a file of one time interval" +
														" exceeds the size limit, it is further splitted. The index of" +
														" size-splitted file is appended after the time," +
														" e.g. 'data.trapcap.201604181000.0'.";
							}
							leaf "size" {
								type "uint16" { range "1..65535"; }
								description "If set, interface will split captured data to individual files" +
														" after size of current file exceeds given threshold. Values are" +
														" in MB and numeric suffix as added to original file name for each" +
														" file in ascending order starting with 0." +
                            " If both 'time' and 'size' options are specified, the data are" +
                            " split primarily by time, and only if a file of one time interval" +
                            " exceeds the size limit, it is further splitted. The index of" +
                            " size-splitted file is appended after the time," +
                            " e.g. 'data.trapcap.201604181000.0'.";
							}
						}
					}
				//Blackhole type has no parameters
				}
			}
  		/* End container out-params */

			
  	  leaf "note" {
  	    type "string";
  	    description "Optional note for interface";
  	  }

			container "stats" {
  			config false;
/*
  			container "in-stats" {
  				when "../direction = 'IN'";
  				description "TODO ";
  
  				leaf "recv-msg-cnt" {
  					type "uint64";
  					description "Number of received messages.";
  				}
  			}
  
  			container "out-stats" {
  				when "../direction != 'IN'";
  				description "TODO ";
  
  	  	  leaf "sent-msg-cnt" {
  	  	    type "uint64";
  	  	    description "Number of sent messages.";
  	  	  }
  
  			}
				*/
leaf "dropped-msg-cnt" {
  	    type "uint64";
  	    description "Number of dropped messages.";
  	  }
			}


			
/*
  	  leaf "sent-msg-cnt" {
  	    type "uint64";
  	    config "false";
  	    description "Number of sent messages.";
  	  }
  	  leaf "dropped-msg-cnt" {
  	    type "uint64";
  	    config "false";
  	    description "Number of dropped messages.";
  	  }
  	  leaf "recv-msg-cnt" {
  	    type "uint64";
  	    config "false";
  	    description "Number of received messages.";
  	  }
  	  leaf "sent-buffer-cnt" {
  	    type "uint64";
  	    config "false";
  	    description "Number of sent buffers.";
  	  }
  	  leaf "autoflush-cnt" {
  	    type "uint64";
  	    config "false";
  	    description "Number of Auto-Flush calls.";
  	  }
  	  leaf "drop-buffer-cnt" {
  	    type "uint64";
  	    config "false";
  	    description "Number of dropped buffers.";
  	  }
  	  leaf "drop-msg-cnt" {
  	    type "uint64";
  	    config "false";
  	    description "Number of dropped messages.";
  	  }
*/
  	} /* End list interface */
	} /* End grouping interfaces list */
}
